# coding: utf-8

"""
Content: Module for the funcsion list of combustion parameters of EBHR
Author: Ayumu Tsuji @Hokkaido University

Description:
At the following part, several function are listed to calculate combustion paremters
such as Re number, firction velocity, thrust and so on.
"""

import numpy as np
from scipy import optimize

def func_Vox(mox, Pc, **kwargs):
    """ Calculate oxidizer port velocity
    
    Paramter
    -----------
    Pc: float
        chamber pressure [Pa]
    mox: float
        oxidizer mass flow rate [kg/s]
        
    Return
    -----------
    Vox: float
        oxidizer port velocity [m/s]
    """
    R_ox = kwargs["Ru"]/kwargs["M_ox"]
    T_ox = kwargs["T_ox"]
    Df = kwargs["Df"]
    a = kwargs["a"]
    rho_ox = Pc/(R_ox*T_ox)
    Vox = mox/(rho_ox*(1-a)*np.pi*np.power(Df,2)/4)
    return Vox

def func_re(P, u, **kwargs):
    T = kwargs["T_ox"]
    Rm = kwargs["Ru"]/kwargs["M_ox"]
    d = kwargs["d"]
    mu = kwargs["mu_ox"]
    rho = P/(Rm*T)
    Re = rho*u*d/mu
    return Re

def func_ustr_lam(P, u, **kwargs):
    T = kwargs["T_ox"]
    Rm = kwargs["Ru"]/kwargs["M_ox"]
    d = kwargs["d"]
    mu = kwargs["mu_ox"]
    rho = P/(Rm*T)
    grad = 4*u/d
    tau = mu*grad
    ustr = np.sqrt(tau/rho)
    return ustr

def func_ustr_turb(P, u, **kwargs):
    T = kwargs["T_ox"]
    Rm = kwargs["Ru"]/kwargs["M_ox"]
    d = kwargs["d"]
    mu = kwargs["mu_ox"]
    rho = P/(Rm*T)
    nu = mu/rho
    lmbd = 0.3164*np.power(u*d/nu, -1/4)
    tau = lmbd*rho*np.power(u, 2)/8
    ustr = np.sqrt(tau/rho)
    return ustr

class class_Pe():
    """Class to calculate Nozzle exit pressure, Pe [Pa].
    Parameter
    ----------
    func_gamma: function
        function generated by the gen_func() method in execute.Read_datset module
    """
    def __init__(self, func_gamma, eps):
        self.func_gamma = func_gamma
        self.eps = eps
        
    def gen_func(self):
        func = self.iterat_Pe
        return(func)

    def iterat_Pe(self, of, Pc):
        """
        of: float
            O/F
        Pc: float
            Chamber pressure [Pa]
        eps: float
            Nozzle expansion ratio
        """
        if of<=0:
            of = 1.0e-2
        try:
            Pe = optimize.newton(self.func_error_eps, Pc/2, maxiter=100, tol=1.0e-3, args=(of, Pc))
        except:
            Pe = optimize.brentq(self.func_error_eps, 1, Pc/2, maxiter=100, xtol=1.0e-3, full_output=False, args=(of, Pc))
        self.Pe=Pe
        return(self.Pe)
    
    def func_error_eps(self, Pe, of , Pc):
        eps_cal = self.func_eps_cal(Pe, of, Pc)
        diff = eps_cal - self.eps
        error = diff/eps_cal
        return(error)
    
    def func_eps_cal(self, Pe, of, Pc):
        gam = self.func_gamma(of, Pc)
        eps_cal = np.power((2/(gam+1)), 1/(gam-1)) * np.power(Pc/Pe, 1/gam) / np.sqrt((gam+1)/(gam-1)*(1-np.power(Pe/Pc, (gam-1)/gam)))
        return(eps_cal)
    


def func_Ve(of, Pc, eps, func_cstr, func_gamma):
    if of<=0:
        of = 1.0e-3
    func_Pe = class_Pe(func_gamma, eps).gen_func()
    gam = func_gamma(of, Pc)
    SON_c = func_cstr(of, Pc)*gam*np.sqrt(np.power(2/(gam+1), (gam+1)/(gam-1)))
    Pe = func_Pe(of, Pc)
    Ve = np.sqrt(2/(gam-1)*(1-np.power(Pe/Pc, (gam-1)/gam))) * SON_c
    return(Ve)
